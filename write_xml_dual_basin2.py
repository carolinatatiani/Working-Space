# Author: Carolina Tatiani
# email: carolina.tatiani@unesp.br
# Created: 26/06/2025
# 
# This script reads two XML files generated by SMOG2, classifies the interactions into common and unique contacts, and writes a new XML file with the classified interactions.


import xml.etree.ElementTree as ET
from lxml import etree
import io
import numpy as np

# output_filename = "dual_basin.xml"
# xsd_file = "OpenSMOG.xsd"

def validate_xml(xml_bytes, xsd_file):
    xmlschema_doc = etree.parse(xsd_file)
    xmlschema = etree.XMLSchema(xmlschema_doc)
    try:
        xmlschema.assertValid(etree.fromstring(xml_bytes))
        return True
    except etree.DocumentInvalid as e:
        print(str(e))
        return False

def parse_xml(filename):
    """Reads the .xml files generated by SMOG2"""
    XML_potential = ET.parse(filename)
    root = XML_potential.getroot()
    interactions = []
    for interaction in root.findall('./contacts/contacts_type[@name="contact_gaussian"]/interaction'):
        i = int(interaction.get('i'))
        j = int(interaction.get('j'))
        A = float(interaction.get('A'))
        r0 = float(interaction.get('r0'))
        sigmaG = float(interaction.get('sigmaG'))
        a = float(interaction.get('a'))
        interactions.append((i, j, A, r0, sigmaG, a))
    return interactions

def classify_contacts(int1, int2):
    '''Returns interactions common, unique to int1, and unique to int2'''
    
    # Find common interactions
    common = [
        (ii1[0], ii1[1], ii1[2], ii1[3], ii1[4], ii2[3], ii2[4], ii1[5])
        for ii1 in int1
        for ii2 in int2
        if ii1[0] == ii2[0] and ii1[1] == ii2[1]
    ]
    
    # Find unique interactions in int1
    unique1 = [
        ii1 for ii1 in int1 
        if not any(ii1[0] == ii2[0] and ii1[1] == ii2[1] for ii2 in int2)
    ]
    
    # Find unique interactions in int2
    unique2 = [
        ii2 for ii2 in int2 
        if not any(ii1[0] == ii2[0] and ii1[1] == ii2[1] for ii1 in int1)
    ]

    return common, unique1, unique2

def write_single_gaussian(root, interactions, name="contact_gaussian", w=1):
    contacts = root.find("contacts")
    if contacts is None:
        contacts = ET.SubElement(root, "contacts")
    
    contacts_type = ET.SubElement(contacts, "contacts_type", name=name)
    expression = ET.SubElement(contacts_type, "expression")
    expression.set("expr", "A*((1+a/(A*r^12))*(1-exp(-(r-r0)^2/(2*sigmaG^2)))-1)")
    parameters = ["A", "r0", "sigmaG", "a"]
    for parameter_name in parameters:
        parameter = ET.SubElement(contacts_type, "parameter")
        parameter.text = parameter_name

    for interaction in interactions:
        interaction_element = ET.SubElement(contacts_type, "interaction")
        interaction_element.set("i", str(interaction[0]))
        interaction_element.set("j", str(interaction[1]))
        interaction_element.set("A", str(interaction[2] * w))
        interaction_element.set("r0", str(interaction[3]))
        interaction_element.set("sigmaG", str(interaction[4]))
        interaction_element.set("a", str(interaction[5]))

def write_double_gaussian(root, interactions, name="double-gaussian", w=1):
    contacts = root.find("contacts")
    if contacts is None:
        contacts = ET.SubElement(root, "contacts")
    
    contacts_type = ET.SubElement(contacts, "contacts_type", name=name)
    expression = ET.SubElement(contacts_type, "expression")
    expression.set("expr", "A*((1+a/(A*r^12))*(1-exp(-(r-r01)^2/(2*sigmaG1^2)))*(1-exp(-(r-r02)^2/(2*sigmaG2^2)))-1)")
    parameters = ["A", "r01", "sigmaG1", "r02", "sigmaG2", "a"]
    for parameter_name in parameters:
        parameter = ET.SubElement(contacts_type, "parameter")
        parameter.text = parameter_name

    for interaction in interactions:
        interaction_element = ET.SubElement(contacts_type, "interaction")
        interaction_element.set("i", str(interaction[0]))
        interaction_element.set("j", str(interaction[1]))
        interaction_element.set("A", str(interaction[2]))
        interaction_element.set("r01", str(interaction[3]))
        interaction_element.set("sigmaG1", str(interaction[4]))
        interaction_element.set("r02", str(interaction[5]))
        interaction_element.set("sigmaG2", str(interaction[6]))
        interaction_element.set("a", str(interaction[7]))


# # Read XML of each model to select the unique interactions
# conf1 = parse_xml('closed.AA.xml')
# conf2 = parse_xml('opened.AA.xml')

# c, u1, u2 = classify_contacts(conf1, conf2)

# np.save("common", c)
# np.save("closed", u1)
# np.save("open", u2)
# #Q=np.loadtxt('Qligand.exclusions')
# #uniqueC = []
# #for close_int in conf2:
# #     found = False
# #     for q in Q:
# #         if q[0] == close_int[0] and q[1] == close_int[1]:
# #             uniqueC.append(close_int)
# #             break
# #     if not found:
# #         if open_int[3] < 1.5 * close_int[3]:
# #            uniqueC.append(close_int)
# # 


# # Create root element
# root = ET.Element("OpenSMOGforces")

# # Add interactions to the root element
# write_single_gaussian(root, u1, 'unique-closed', 0.625)
# write_double_gaussian(root, c, 'common-contacts')
# write_single_gaussian(root, u2, 'unique-open', 1.375)
# #write_single_gaussian(root, uniqueC, 'unique-closed', 1)#len(uniqueC)/len(u2)*1.36)#*1.)

# # Finalize the XML tree
# tree = ET.ElementTree(root)
# ET.indent(tree, '  ')
# tree.write(output_filename, encoding="ISO-8859-1", xml_declaration=True)

# # Validate the XML file

# with open(output_filename, 'rb') as f:
#     xml_bytes = f.read()

# if validate_xml(xml_bytes, xsd_file):
#     print("XML is valid against the XSD schema.")
# else:
#     print("XML is NOT valid against the XSD schema.")
